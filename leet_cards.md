<!-- flashcard 1 -->

## Front

Sliding Window Pattern

## Back

- Efficiently process subarrays or substrings within linear data structures.  
- Adjust window size dynamically to find desired subarray properties.  

<!-- end flashcard 1 -->

<!-- flashcard 2 -->

## Front

Identifying Sliding Window Problems

## Back

- Look for problems involving contiguous subarrays or substrings.  
- Common in scenarios asking for longest, shortest, or specific sum subarrays.  

<!-- end flashcard 2 -->

<!-- flashcard 3 -->

## Front

Two Pointers Pattern

## Back

- Use two pointers to iterate through data structures for efficient comparisons.  
- Ideal for finding pairs or subarrays meeting specific criteria.  

<!-- end flashcard 3 -->

<!-- flashcard 4 -->

## Front

Identifying Two Pointers Problems

## Back

- Problems involving sorted arrays or linked lists.  
- Tasks requiring finding pairs, triplets, or subarrays with certain sums.  

<!-- end flashcard 4 -->

<!-- flashcard 5 -->

## Front

Fast and Slow Pointers Pattern

## Back

- Utilize two pointers moving at different speeds to detect cycles.  
- Commonly used in cyclic linked lists or arrays.  

<!-- end flashcard 5 -->

<!-- flashcard 6 -->

## Front

Identifying Fast and Slow Pointers Problems

## Back

- Problems involving loops in linked lists or arrays.  
- Scenarios requiring detection of cycles or finding the middle element.  

<!-- end flashcard 6 -->

<!-- flashcard 7 -->

## Front

Merge Intervals Pattern

## Back

- Efficiently handle overlapping intervals by merging them.  
- Sort intervals and merge those that overlap.  

<!-- end flashcard 7 -->

<!-- flashcard 8 -->

## Front

Identifying Merge Intervals Problems

## Back

- Problems involving intervals, such as meeting times or ranges.  
- Tasks requiring merging or inserting intervals.  

<!-- end flashcard 8 -->

<!-- flashcard 9 -->

## Front

Cyclic Sort Pattern

## Back

- Sort numbers when given a range of 1 to 'n' with constant space.  
- Place each number at its correct index iteratively.  

<!-- end flashcard 9 -->

<!-- flashcard 10 -->

## Front

Identifying Cyclic Sort Problems

## Back

- Problems involving finding missing or duplicate numbers in a range.  
- Scenarios where numbers are bound within a specific range.  

<!-- end flashcard 10 -->

<!-- flashcard 11 -->

## Front

In-place Reversal of Linked List Pattern

## Back

- Reverse linked list nodes in-place for specific sections.  
- Modify pointers directly without extra space.  

<!-- end flashcard 11 -->

<!-- flashcard 12 -->

## Front

Identifying In-place Reversal Problems

## Back

- Problems requiring reversal of linked list segments.  
- Tasks involving reordering nodes without extra space.  

<!-- end flashcard 12 -->

<!-- flashcard 13 -->

## Front

Tree BFS Pattern

## Back

- Traverse tree level by level using a queue.  
- Useful for shortest path and level order traversal.  

<!-- end flashcard 13 -->

<!-- flashcard 14 -->

## Front

Identifying Tree BFS Problems

## Back

- Problems requiring level order traversal of trees.  
- Scenarios involving shortest path in unweighted trees.  

<!-- end flashcard 14 -->

<!-- flashcard 15 -->

## Front

Tree DFS Pattern

## Back

- Traverse tree using pre-order, in-order, or post-order methods.  
- Utilize recursion or stack for traversal.  

<!-- end flashcard 15 -->

<!-- flashcard 16 -->

## Front

Identifying Tree DFS Problems

## Back

- Problems requiring exploration of all tree paths.  
- Scenarios involving path sums or subtree searches.  

<!-- end flashcard 16 -->

<!-- flashcard 17 -->

## Front

Two Heaps Pattern

## Back

- Use two heaps to manage median or 'K' largest/smallest elements.  
- Balance a max-heap and min-heap for efficient retrievals.  

<!-- end flashcard 17 -->

<!-- flashcard 18 -->

## Front

Identifying Two Heaps Problems

## Back

- Problems involving continuous median calculations.  
- Scenarios requiring dynamic insertion and retrieval of 'K' elements.  

<!-- end flashcard 18 -->

<!-- flashcard 19 -->

## Front

Subsets Pattern

## Back

- Generate all subsets or combinations of a set.  
- Use backtracking or iterative methods to explore possibilities.  

<!-- end flashcard 19 -->

<!-- flashcard 20 -->

## Front

Identifying Subsets Problems

## Back

- Problems requiring generation of power sets or combinations.  
- Tasks involving exploration of all subset possibilities.  

<!-- end flashcard 20 -->

<!-- flashcard 21 -->

## Front

Modified Binary Search Pattern

## Back

- Apply binary search on sorted arrays with modifications.  
- Efficiently find elements or conditions in logarithmic time.  

<!-- end flashcard 21 -->

<!-- flashcard 22 -->

## Front

Identifying Modified Binary Search Problems

## Back

- Problems involving searching in sorted or rotated arrays.  
- Scenarios requiring efficient element location.  

<!-- end flashcard 22 -->

<!-- flashcard 23 -->

## Front

Top 'K' Elements Pattern

## Back

- Use heaps to find top 'K' largest or smallest elements.  
- Maintain a heap of size 'K' for efficient retrievals.  

<!-- end flashcard 23 -->

<!-- flashcard 24 -->

## Front

Identifying Top 'K' Elements Problems

## Back

- Problems requiring retrieval of top or bottom 'K' elements.  
- Scenarios involving frequency counts or largest/smallest values.  

<!-- end flashcard 24 -->

<!-- flashcard 25 -->

## Front

K-way Merge Pattern

## Back

- Merge 'K' sorted arrays or lists efficiently.  
- Use a min-heap to keep track of smallest elements.  

<!-- end flashcard 25 -->

<!-- flashcard 26 -->

## Front

Identifying K-way Merge Problems

## Back

- Problems involving merging multiple sorted sequences.  
- Scenarios requiring efficient combination of sorted data.  

<!-- end flashcard 26 -->

<!-- flashcard 27 -->

## Front

Topological Sort Pattern

## Back

- Order elements based on dependencies using directed graphs.  
- Utilize DFS or Kahn's algorithm for sorting.  

<!-- end flashcard 27 -->

<!-- flashcard 28 -->

## Front

Identifying Topological Sort Problems

## Back

- Problems involving task scheduling with dependencies.  
- Scenarios requiring linear ordering of dependent tasks.  

<!-- end flashcard 28 -->


<!-- flashcard 29 -->

## Front

Union Find UseCases

## Back

- Detect cycles in graphs (e.g., "Graph Valid Tree")  
- Find connected components (e.g., "Number of Provinces")  
- Group similar items (e.g., "Accounts Merge")  

<!-- end flashcard 29 -->

<!-- flashcard 30 -->

## Front

Union Find Implementation

## Back

- Core idea: Track and merge disjoint sets efficiently  
- Use a parent array to represent the forest  
- `find(x)`: Find the root with path compression  
- `union(x, y)`: Link roots by rank or size  

<!-- end flashcard 30 -->